// Definirea funcției de debounce pentru gestionarea evenimentelor de scroll
function e(t){
    this.callback = t;
    this.ticking = !1;
}

// Verifică dacă elementul este fereastra browser-ului
function i(t){
    return t && "undefined" != typeof window && (t === window || t.nodeType);
}

// Funcția extend pentru combinarea a două obiecte
function n(t){
    if (arguments.length <= 0) throw new Error("Lipsește argumentele în funcția extend");
    var o, s, e = t || {};
    for (s = 1; s < arguments.length; s++){
        var a = arguments[s] || {};
        for (o in a) "object" != typeof e[o] || i(e[o]) ? e[o] = e[o] || a[o] : e[o] = n(e[o], a[o]);
    }
    return e;
}

// Funcție utilitară pentru transformarea unui număr sau obiect într-un obiect cu proprietăți up și down
function o(t){
    return t === Object(t) ? t : {down: t, up: t};
}

// Constructorul pentru funcția debounce
e.prototype = {
    constructor: e,
    update: function(){
        this.callback && this.callback(),
        this.ticking = !1
    },
    requestTick: function(){
        this.ticking || (requestAnimationFrame(this.rafCallback || (this.rafCallback = this.update.bind(this))), this.ticking = !0)
    },
    handleEvent: function(){
        this.requestTick()
    }
}

// Constructorul pentru plugin-ul Headroom
function s(t){
    t = n(t, s.options),
    this.lastKnownScrollY = 0,
    this.elem = t,
    this.tolerance = o(t.tolerance),
    this.classes = t.classes,
    this.offset = t.offset,
    this.scroller = t.scroller,
    this.initialised = !1,
    this.onPin = t.onPin,
    this.onUnpin = t.onUnpin,
    this.onTop = t.onTop,
    this.onNotTop = t.onNotTop,
    this.onBottom = t.onBottom,
    this.onNotBottom = t.onNotBottom
}

// Setările implicite ale plugin-ului Headroom
s.options = {
    tolerance: {up: 0, down: 0},
    offset: 0,
    scroller: window,
    classes: {
        pinned: "headroom--pinned",
        unpinned: "headroom--unpinned",
        top: "headroom--top",
        notTop: "headroom--not-top",
        bottom: "headroom--bottom",
        notBottom: "headroom--not-bottom",
        initial: "headroom"
    }
}

// Metoda init pentru inițializarea plugin-ului Headroom
s.prototype.init = function(){
    return s.cutsTheMustard ? (this.debouncer = new e(this.update.bind(this)), this.elem.classList.add(this.classes.initial), setTimeout(this.attachEvent.bind(this), 100), this) : void 0
}

// Metoda destroy pentru distrugerea plugin-ului Headroom
s.prototype.destroy = function(){
    var t = this.classes;
    this.initialised = !1,
    this.elem.classList.remove(t.unpinned, t.pinned, t.top, t.notTop, t.initial),
    this.scroller.removeEventListener("scroll", this.debouncer, !1)
}

// Metoda pentru atașarea evenimentului de scroll
s.prototype.attachEvent = function(){
    this.initialised || (this.lastKnownScrollY = this.getScrollY(), this.initialised = !0, this.scroller.addEventListener("scroll", this.debouncer, !1), this.debouncer.handleEvent())
}

// Metoda pentru fixarea elementului de sus
s.prototype.unpin = function(){
    var t = this.elem.classList,
        e = this.classes;
    (t.contains(e.pinned) || !t.contains(e.unpinned)) && (t.add(e.unpinned), t.remove(e.pinned), this.onUnpin && this.onUnpin.call(this))
}

// Metoda pentru fixarea elementului de jos
s.prototype.pin = function(){
    var t = this.elem.classList,
        e = this.classes;
    t.contains(e.unpinned) && (t.remove(e.unpinned), t.add(e.pinned), this.onPin && this.onPin.call(this))
}

// Metoda pentru verificarea dacă elementul este în partea de sus a paginii
s.prototype.top = function(){
    var t = this.elem.classList,
        e = this.classes;
    t.contains(e.top) || (t.add(e.top), t.remove(e.notTop), this.onTop && this.onTop.call(this))
}

// Metoda pentru verificarea dacă elementul nu este în partea de sus a paginii
s.prototype.notTop = function(){
    var t = this.elem.classList,
        e = this.classes;
    t.contains(e.notTop) || (t.add(e.notTop), t.remove(e.top), this.onNotTop && this.onNotTop.call(this))
}

// Metoda pentru verificarea dacă elementul este în partea de jos a paginii
s.prototype.bottom = function(){
    var t = this.elem.classList,
        e = this.classes;
    t.contains(e.bottom) || (t.add(e.bottom), t.remove(e.notBottom), this.onBottom && this.onBottom.call(this))
}

// Metoda pentru verificarea dacă elementul nu este în partea de jos a paginii
s.prototype.notBottom = function(){
    var t = this.elem.classList,
        e = this.classes;
    t.contains(e.notBottom) || (t.add(e.notBottom), t.remove(e.bottom), this.onNotBottom && this.onNotBottom.call(this))
}

// Metoda pentru actualizarea stării elementului
s.prototype.update = function(){
    var t = this.getScrollY(),
        e = t > this.lastKnownScrollY ? "down" : "up",
        i = this.toleranceExceeded(t, e);
    this.isOutOfBounds(t) || (t <= this.offset ? this.top() : this.notTop(), t + this.getViewportHeight() >= this.getScrollerHeight() ? this.bottom() : this.notBottom(), this.shouldUnpin(t, i) ? this.unpin() : this.shouldPin(t, i) && this.pin(), this.lastKnownScrollY = t)
}

// Verifică dacă browser-ul acceptă funcționalitățile necesare plugin-ului Headroom
s.cutsTheMustard = "undefined" != typeof t && t.rAF && t.bind && t.classList,

// Returnează constructorul plugin-ului Headroom
function(){
    "use strict";
    return function(t){
        "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? module.exports = t() : t.Headroom = t()
    }(s)
}
